<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body></body>
  <script>
    // let arr = [1, 2, 3, 4];
    // let sum = arr.reduce((prev, cur, index, arr) => {
    //   console.log(prev, cur, index);
    //   return prev + cur;
    // });
    // console.log(sum);

    var obj = { 0: 'a', 1: 'b', 2: 'c', length: 3 };

    const newArr = Array.from(
      obj,
      function (value, index) {
        // console.log(value, index, this, arguments.length);
        return value.repeat(3); //必须指定返回值，否则返回 undefined
      },
      obj
    );
    // console.log(obj);
    // console.log(newArr);

    var obj2 = { 0: 'a', 1: 'b', 2: 'c', length: 3 };
    const newArr2 = Array.from(obj2);
    // console.log(newArr2);

    const arr = [0, 0, 0, 0, 0];
    arr.fill(5, 1, 3);
    // console.log(arr); // [0, 5, 5, 0, 0]

    // Object.keys()：返回包含对象键名的数组；
    // Object.values()：返回包含对象键值的数组；
    // Object.entries()：返回包含对象键名和键值的数组。

    // let obj = {
    //   id: 1,
    //   name: 'hello',
    //   age: 18,
    // };
    // console.log(Object.keys(obj)); // 输出结果: ['id', 'name', 'age']
    // console.log(Object.values(obj)); // 输出结果: [1, 'hello', 18]
    // console.log(Object.entries(obj)); // 输出结果: [['id', 1], ['name', 'hello'], ['age', 18]

    // 1. for await…of
    // function Gen(time) {
    //   return new Promise((resolve, reject) => {
    //     setTimeout(() => {
    //       resolve(time);
    //     }, time);
    //   });
    // }
    // async function test() {
    //   let arr = [Gen(2000), Gen(300), Gen(3000)];
    //   for await (const item of arr) {
    //     // console.log(Date.now(), item);
    //   }
    // }
    // test();

    // const promises = new Promise((resolve, reject) => {
    //   setTimeout(() => {
    //     resolve('3');
    //   }, 100);
    // });
    // promises
    //   .then((res) => {
    //     console.log('then', res);
    //   })
    //   .catch(() => {
    //     console.log('catch');
    //   })
    //   .finally(() => {
    //     console.log('finally');
    //   });

    // 2. flat()和flatMap()
    // [1, [2, 3]].flat()        // [1, 2, 3]
    // [1, [2, [3, 4]]].flat()   // [1, 2, [3, 4]]
    // 在不传参数时，flat()默认只会打平一级嵌套，如果想要打平更多的层级，就需要传给flat()一个数值参数，这个参数表示要打平的层级数：

    // [1, [2, [3, 4]]].flat(2)  // [1, 2, 3, 4]
    // 如果数组中存在空项，会直接跳过：

    // [1, [2, , 3]].flat(2))   //  [1, 2, 3]
    // 如果传入的参数小于等于0，就会返回原数组：

    // [1, [2, [3, [4, 5]]]].flat(0);    //  [1, [2, [3, [4, 5]]]]
    // [1, [2, [3, [4, 5]]]].flat(-10);  //  [1, [2, [3, [4, 5]]]]

    // 1. BigInt
    // 2. 空值合并运算符（??）
    // 3. 可选链操作符（?.）
    // a?.[x];
    // // 等同于
    // a == null ? undefined : a[x];

    // a?.b();
    // // 等同于
    // a == null ? undefined : a.b();

    // a?.();
    // // 等同于
    // a == null ? undefined : a();

    // const resolved = Promise.resolve(2);
    // const rejected = Promise.reject(-1);
    // const allSettledPromise = Promise.allSettled([resolved, rejected]);
    // allSettledPromise.then(function (results) {
    //   console.log(results);
    // });
    // 返回结果：
    // [
    //    { status: 'fulfilled', value: 2 },
    //    { status: 'rejected', reason: -1 }
    // ]

    // for (const match of 'abcabc'.matchAll(/a/g)) {
    //   console.log(match);
    // }
    //["a", index: 0, input: "abcabc", groups: undefined]
    //["a", index: 3, input: "abcabc", groups: undefined]

    // 1. Object.hasOwn()
    const example = {
      property: '123',
    };

    console.log(example.hasOwnProperty('property'));
    console.log(Object.prototype.hasOwnProperty.call(example, 'property'));
    console.log(Object.hasOwn(example, 'property'));

    // 2. Array.at()
    // const array = [0, 1, 2, 3, 4, 5];
    // console.log(array[array.length - 1]); // 5
    // console.log(array.at(-1)); // 5
    // console.log(array[array.lenght - 2]); // 4
    // console.log(array.at(-2)); // 4

    // const str = 'hello world';
    // console.log(str[str.length - 1]); // d
    // console.log(str.at(-1)); // d

    // 3. error.cause
    function readFiles(filePaths) {
      return filePaths.map((filePath) => {
        try {
          // ···
        } catch (error) {
          throw new Error(`While processing ${filePath}`, { cause: error });
        }
      });
    }

    // 4. Top-level Await
  </script>
</html>
